
.. _program_listing_file_.._canopen_402_driver_include_canopen_402_driver_canopen_402_driver.hpp:

Program Listing for File canopen_402_driver.hpp
===============================================

|exhale_lsh| :ref:`Return to documentation for file <file_.._canopen_402_driver_include_canopen_402_driver_canopen_402_driver.hpp>` (``../canopen_402_driver/include/canopen_402_driver/canopen_402_driver.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef MC_DEVICE_NODE_HPP
   #define MC_DEVICE_NODE_HPP
   
   #include "canopen_402_driver/visibility_control.h"
   #include "std_srvs/srv/trigger.hpp"
   #include "std_msgs/msg/float64.hpp"
   #include "canopen_interfaces/srv/co_target_double.hpp"
   #include "canopen_proxy_driver/canopen_proxy_driver.hpp"
   #include "canopen_402_driver/motor.hpp"
   
   using namespace std::chrono_literals;
   using namespace ros2_canopen;
   using namespace canopen_402;
   namespace ros2_canopen
   {
       class MotionControllerDriver : public ProxyDriver
       {
       private:
           std::shared_ptr<MCDeviceDriver> mc_driver_;
           std::shared_ptr<Motor402> motor_;
           rclcpp::TimerBase::SharedPtr timer_;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_init_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_halt_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_recover_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_position_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_torque_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_velocity_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_cyclic_velocity_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_cyclic_position_service;
           rclcpp::Service<canopen_interfaces::srv::COTargetDouble>::SharedPtr handle_set_target_service;
           rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr publish_actual_position;
           rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr publish_actual_speed;
           rclcpp::CallbackGroup::SharedPtr timer_group;
           uint32_t period_ms_;
           bool intialised;
           void register_services();
   
       public:
           explicit MotionControllerDriver(const rclcpp::NodeOptions &options)
               : ProxyDriver(options)
           {
               intialised = false;
           }
   
           void run()
           {
               if(!intialised)
               {
                   RCLCPP_INFO(this->get_logger(), "Intitialising Device and Objects");
                   timer_->cancel();
                   intialised = true;
                   motor_->registerDefaultModes();
                   mc_driver_->validate_objs();
                   timer_= this->create_wall_timer(
                           std::chrono::milliseconds(period_ms_), std::bind(&MotionControllerDriver::run, this), timer_group);
               }
   
               motor_->handleRead();
               motor_->handleWrite();
               //motor_->handleDiag();
               publish();
           }
   
           void init(ev::Executor &exec,
                     canopen::AsyncMaster &master,
                     uint8_t node_id,
                     std::shared_ptr<ros2_canopen::ConfigurationManager>  config) noexcept override;
   
       protected:
           virtual void on_rpdo(COData data) override
           {
               RCLCPP_INFO(this->get_logger(), "on_rpo not implemented");
           }
   
       private:
           std::atomic<bool> active;
   
           void handle_init(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_recover(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_halt(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_position(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_velocity(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_cyclic_position(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
   
           void handle_set_mode_cyclic_velocity(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_torque(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_target(
               const canopen_interfaces::srv::COTargetDouble::Request::SharedPtr request,
               canopen_interfaces::srv::COTargetDouble::Response::SharedPtr response);
   
           void publish();
       };
   
   }
   
   #endif
