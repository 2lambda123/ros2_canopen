
.. _program_listing_file_.._canopen_402_driver_include_canopen_402_driver_lifecycle_canopen_402_driver.hpp:

Program Listing for File lifecycle_canopen_402_driver.hpp
=========================================================

|exhale_lsh| :ref:`Return to documentation for file <file_.._canopen_402_driver_include_canopen_402_driver_lifecycle_canopen_402_driver.hpp>` (``../canopen_402_driver/include/canopen_402_driver/lifecycle_canopen_402_driver.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef MC_DEVICE_NODE_HPP
   #define MC_DEVICE_NODE_HPP
   
   #include "canopen_402_driver/visibility_control.h"
   #include "std_srvs/srv/trigger.hpp"
   #include "sensor_msgs/msg/joint_state.hpp"
   #include "canopen_interfaces/srv/co_target_double.hpp"
   #include "canopen_proxy_driver/lifecycle_canopen_proxy_driver.hpp"
   #include "canopen_402_driver/motor.hpp"
   
   using namespace std::chrono_literals;
   using namespace ros2_canopen;
   using namespace canopen_402;
   namespace ros2_canopen
   {
       class LifecycleMotionControllerDriver : public LifecycleProxyDriver
       {
       private:
           std::shared_ptr<MCDeviceDriver> mc_driver_;
           std::shared_ptr<Motor402> motor_;
           rclcpp::TimerBase::SharedPtr timer_;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_init_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_halt_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_recover_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_position_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_torque_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_velocity_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_cyclic_velocity_service;
           rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr handle_set_mode_cyclic_position_service;
           rclcpp::Service<canopen_interfaces::srv::COTargetDouble>::SharedPtr handle_set_target_service;
           rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr publish_joint_state;
           uint32_t period_ms_;
           virtual bool add() override;
           virtual void register_ros_interface() override;
           virtual void start_timers() override;
           virtual void stop_timers() override;
   
       public:
           explicit LifecycleMotionControllerDriver(const rclcpp::NodeOptions &options)
               : LifecycleProxyDriver(options)
           {
           }
           void run()
           {
               motor_->handleRead();
               motor_->handleWrite();
               // motor_->handleDiag();
               publish();
           }
   
           void init() override
           {
               LifecycleProxyDriver::init();
               period_ms_ = 20;
           }
   
       protected:
           void read_config() override
           {
               auto period = this->config_["period"].as<uint32_t>();
               period_ms_ = period;
           }
   
           virtual void on_rpdo(COData data) override
           {
               RCLCPP_INFO(this->get_logger(), "on_rpo not implemented");
           }
   
           rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
           on_configure(const rclcpp_lifecycle::State &state);
   
           rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
           on_activate(const rclcpp_lifecycle::State &state);
   
           rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
           on_deactivate(const rclcpp_lifecycle::State &state);
   
           rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
           on_cleanup(const rclcpp_lifecycle::State &state);
   
           rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
           on_shutdown(const rclcpp_lifecycle::State &state);
   
       private:
   
           void handle_init(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_recover(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_halt(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_position(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_velocity(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_cyclic_position(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_cyclic_velocity(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_mode_torque(
               const std_srvs::srv::Trigger::Request::SharedPtr request,
               std_srvs::srv::Trigger::Response::SharedPtr response);
   
           void handle_set_target(
               const canopen_interfaces::srv::COTargetDouble::Request::SharedPtr request,
               canopen_interfaces::srv::COTargetDouble::Response::SharedPtr response);
   
           void publish();
       };
   
   }
   
   #endif
