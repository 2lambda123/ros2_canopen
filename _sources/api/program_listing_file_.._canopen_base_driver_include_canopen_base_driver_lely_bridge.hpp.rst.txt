
.. _program_listing_file_.._canopen_base_driver_include_canopen_base_driver_lely_bridge.hpp:

Program Listing for File lely_bridge.hpp
========================================

|exhale_lsh| :ref:`Return to documentation for file <file_.._canopen_base_driver_include_canopen_base_driver_lely_bridge.hpp>` (``../canopen_base_driver/include/canopen_base_driver/lely_bridge.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //    Copyright 2022 Christoph Hellmann Santos
   //
   //    Licensed under the Apache License, Version 2.0 (the "License");
   //    you may not use this file except in compliance with the License.
   //    You may obtain a copy of the License at
   //
   //        http://www.apache.org/licenses/LICENSE-2.0
   //
   //    Unless required by applicable law or agreed to in writing, software
   //    distributed under the License is distributed on an "AS IS" BASIS,
   //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   //    See the License for the specific language governing permissions and
   //    limitations under the License.
   
   #ifndef CANOPEN_BASE_DRIVER__LELY_BRIDGE_HPP_
   #define CANOPEN_BASE_DRIVER__LELY_BRIDGE_HPP_
   
   #include <lely/coapp/fiber_driver.hpp>
   #include <lely/coapp/master.hpp>
   #include <lely/ev/future.hpp>
   #include <lely/ev/co_task.hpp>
   
   #include <memory>
   #include <mutex>
   #include <atomic>
   #include <future>
   #include <thread>
   #include <vector>
   #include <condition_variable>
   
   #include "canopen_core/exchange.hpp"
   
   using namespace std::chrono_literals;
   using namespace lely;
   
   namespace ros2_canopen
   {
   
   class LelyBridge : public canopen::FiberDriver
   {
     class TPDOWriteTask : public ev::CoTask
     {
     public:
       COData data;
       LelyBridge * driver;
       std::mutex mtx;
       explicit TPDOWriteTask(ev_exec_t * exec)
       : ev::CoTask(exec)
       {
         // Lock and load
         mtx.lock();
       }
       void operator()() noexcept
       {
         std::scoped_lock<util::BasicLockable> lk(driver->tpdo_event_mutex);
         switch (data.type_) {
           case CODataTypes::COData8:
             driver->tpdo_mapped[data.index_][data.subindex_] =
               static_cast<uint8_t>(data.data_);
             break;
           case CODataTypes::COData16:
             driver->tpdo_mapped[data.index_][data.subindex_] =
               static_cast<uint16_t>(data.data_);
             break;
           case CODataTypes::COData32:
             driver->tpdo_mapped[data.index_][data.subindex_] =
               static_cast<uint32_t>(data.data_);
             break;
           default:
             break;
         }
         driver->master.TpdoWriteEvent(driver->id(), data.index_, data.subindex_);
         // Unlock when done
         mtx.unlock();
       }
     };
   
   private:
     // SDO Read synchronisation items
     std::shared_ptr<std::promise<COData>> sdo_read_data_promise;
     std::shared_ptr<std::promise<bool>> sdo_write_data_promise;
     std::mutex sdo_mutex;
     bool running;
     std::condition_variable sdo_cond;
   
     // NMT synchronisation items
     std::promise<canopen::NmtState> nmt_state_promise;
     std::atomic<bool> nmt_state_is_set;
     std::mutex nmt_mtex;
   
     // RPDO synchronisation items
     std::promise<COData> rpdo_promise;
     std::atomic<bool> rpdo_is_set;
     std::mutex pdo_mtex;
   
     std::vector<std::shared_ptr<TPDOWriteTask>> tpdo_tasks;
     uint8_t nodeid;
   
     void
     OnState(canopen::NmtState state) noexcept override;
   
     void
     OnRpdoWrite(uint16_t idx, uint8_t subidx) noexcept override;
   
   public:
     using FiberDriver::FiberDriver;
   
     LelyBridge(ev_exec_t * exec, canopen::AsyncMaster & master, uint8_t id)
     : FiberDriver(exec, master, id)
     {
       nodeid = id;
       running = false;
     }
   
     std::future<bool> async_sdo_write(COData data);
   
     std::future<COData> async_sdo_read(COData data);
   
     std::future<canopen::NmtState> async_request_nmt();
   
     std::future<COData> async_request_rpdo();
   
     void tpdo_transmit(COData data);
   
     void nmt_command(canopen::NmtCommand command);
   
     uint8_t get_id();
   };
   
   }  // namespace ros2_canopen
   
   
   #endif  // CANOPEN_BASE_DRIVER__LELY_BRIDGE_HPP_
