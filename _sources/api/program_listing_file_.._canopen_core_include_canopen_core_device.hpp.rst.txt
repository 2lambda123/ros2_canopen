
.. _program_listing_file_.._canopen_core_include_canopen_core_device.hpp:

Program Listing for File device.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_.._canopen_core_include_canopen_core_device.hpp>` (``../canopen_core/include/canopen_core/device.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //    Copyright 2022 Harshavadan Deshpande
   //                   Christoph Hellmann Santos
   //
   //    Licensed under the Apache License, Version 2.0 (the "License");
   //    you may not use this file except in compliance with the License.
   //    You may obtain a copy of the License at
   //
   //        http://www.apache.org/licenses/LICENSE-2.0
   //
   //    Unless required by applicable law or agreed to in writing, software
   //    distributed under the License is distributed on an "AS IS" BASIS,
   //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   //    See the License for the specific language governing permissions and
   //    limitations under the License.
   
   #ifndef DEVICE_HPP_
   #define DEVICE_HPP_
   
   #include <lely/coapp/fiber_driver.hpp>
   #include <lely/coapp/master.hpp>
   #include <lely/coapp/slave.hpp>
   #include <lely/io2/linux/can.hpp>
   #include <lely/io2/sys/io.hpp>
   #include <lely/io2/sys/sigset.hpp>
   #include <lely/io2/sys/timer.hpp>
   #include <rclcpp/rclcpp.hpp>
   #include "canopen_core/configuration_manager.hpp"
   
   using namespace lely;
   
   namespace ros2_canopen
   {
       // Base class for driver plugin
       // Pluginlib API does allows only default constructors
       class DriverInterface : public rclcpp::Node
       {
       public:
           DriverInterface(const std::string &node_name,
                                const rclcpp::NodeOptions &node_options = rclcpp::NodeOptions()) : rclcpp::Node(node_name, node_options) {}
   
           virtual void init(ev::Executor &exec,
                             canopen::AsyncMaster &master,
                             uint8_t node_id,
                             std::shared_ptr<ros2_canopen::ConfigurationManager> config
                             ) noexcept = 0;
   
           virtual void remove(ev::Executor &exec,
                               canopen::AsyncMaster &master,
                               uint8_t node_id) noexcept = 0;
       };
   
       class MasterInterface : public rclcpp::Node
       {
       protected:
           std::string dcf_txt_;
           std::string dcf_bin_;
           std::string can_interface_name_;
           uint8_t node_id_;
           std::shared_ptr<ros2_canopen::ConfigurationManager> config_;
   
       public:
           MasterInterface(
               const std::string &node_name,
               const rclcpp::NodeOptions &node_options) : rclcpp::Node(node_name, node_options)
           {
   
           }
           virtual void init(
               std::string dcf_txt,
               std::string dcf_bin,
               std::string can_interface_name,
               uint8_t nodeid,
               std::shared_ptr<ros2_canopen::ConfigurationManager> config
           )
           {
               dcf_txt_ = dcf_txt;
               dcf_bin_ = dcf_bin;
               can_interface_name_ = can_interface_name;
               node_id_ = nodeid;
               config_ = config;
           }
   
           virtual void add_driver(std::shared_ptr<ros2_canopen::DriverInterface>, uint8_t node_id) = 0;
   
           virtual void remove_driver(std::shared_ptr<ros2_canopen::DriverInterface>, uint8_t node_id) = 0;
       };
   
       class SlaveDevice : public rclcpp::Node, public canopen::BasicSlave
       {
       public:
           SlaveDevice(io::Timer &timer,
                       io::CanChannel &chan,
                       std::string &dcf_txt,
                       u_int32_t id,
                       const std::string &devName)
               : rclcpp::Node(devName),
                 canopen::BasicSlave(timer, chan, dcf_txt, "", id) {}
   
           // ROS interfaces
       };
   } // end ros2_canopen namespace
   
   #endif // DEVICE_HPP_
